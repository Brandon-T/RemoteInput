#ifndef NATIVEHOOKS_HXX_INCLUDED
#define NATIVEHOOKS_HXX_INCLUDED

#include <windows.h>
#include <memory>
#include <thread>
#include "JavaInternal.hxx"


typedef union BGRA
{
    struct {std::uint8_t B, G, R, A;};
    std::uint32_t Colour;
} *PBGRA;

class Image
{
private:
    void* pixels;
    unsigned int width, height;
    void process_pixels(void* out, void* in);
    void unprocess_pixels(void* out, void* in);

public:
    Image(void* pixels, unsigned int width, unsigned int height);
    ~Image() {free(pixels); pixels = nullptr;}

    Image(const Image &other) = delete;
    Image(Image &&other) = delete;
    Image& operator = (const Image &other) = delete;

    unsigned int GetWidth() const {return width;}
    unsigned int GetHeight() const {return height;}
    void* GetPixels() const {return pixels;}

    bool Save(const char* path);
};

void Image::process_pixels(void* out, void* in)
{
    unsigned int i, j;
    BGRA* pOut = (BGRA*)out;
    unsigned char* pIn = (unsigned char*)in;

    for (i = 0; i < height; ++i)
    {
        for (j = 0; j < width; ++j)
        {
            pOut[(height - 1 - i) * width + j].B = *(pIn++);
            pOut[(height - 1 - i) * width + j].G = *(pIn++);
            pOut[(height - 1 - i) * width + j].R = *(pIn++);
            pOut[(height - 1 - i) * width + j].A = *(pIn++);
        }
    }
}

void Image::unprocess_pixels(void* out, void* in)
{
    unsigned int i, j;
    unsigned char* pOut = (unsigned char*)out;
    BGRA* pIn = (BGRA*)in;

    for (i = 0; i < height; ++i)
    {
        for (j = 0; j < width; ++j)
        {
            *(pOut++) = pIn[(height - 1 - i) * width + j].B;
            *(pOut++) = pIn[(height - 1 - i) * width + j].G;
            *(pOut++) = pIn[(height - 1 - i) * width + j].R;
            *(pOut++) = pIn[(height - 1 - i) * width + j].A;
        }
    }
}

Image::Image(void* pixels, unsigned int width, unsigned int height) : pixels(width > 0 && height > 0 ? malloc(((width * 32 + 31) / 32) * 4 * height) : nullptr), width(width > 0 ? width : 0), height(height > 0 ? height : 0)
{
    if (width > 0 && height > 0 && pixels)
    {
        process_pixels(this->pixels, pixels);
    }
}

bool Image::Save(const char* path)
{
    FILE* file = fopen(path, "wb");

    if (file)
    {
        unsigned short bpp = 32;
        unsigned int trash = 0;
        unsigned short planes = 1;
        unsigned int biSize = 108;
        unsigned int offset = 122;
        unsigned int compression = 3;
        unsigned short type = 0x4D42;
        unsigned int size = ((width * bpp + 31) / 32) * 4 * height;
        unsigned int bfSize = offset + size;
        unsigned int masks[4] = {0xFF0000, 0xFF00, 0xFF, 0xFF000000};
        unsigned int csType = 0x73524742;
        unsigned int epts[9] = {0};

        fwrite(&type, sizeof(type), 1, file);
        fwrite(&bfSize, sizeof(bfSize), 1, file);
        fwrite(&trash, sizeof(trash), 1, file);
        fwrite(&offset, sizeof(offset), 1, file);
        fwrite(&biSize, sizeof(biSize), 1, file);
        fwrite(&width, sizeof(width), 1, file);
        fwrite(&height, sizeof(height), 1, file);
        fwrite(&planes, sizeof(planes), 1, file);
        fwrite(&bpp, sizeof(bpp), 1, file);
        fwrite(&compression, sizeof(compression), 1, file);
        fwrite(&size, sizeof(size), 1, file);
        fwrite(&trash, sizeof(trash), 1, file);
        fwrite(&trash, sizeof(trash), 1, file);
        fwrite(&trash, sizeof(trash), 1, file);
        fwrite(&trash, sizeof(trash), 1, file);
        fwrite(&masks, sizeof(masks), 1, file);
        fwrite(&csType, sizeof(csType), 1, file);
        fwrite(&epts, sizeof(epts), 1, file);
        fwrite(&epts, sizeof(trash), 1, file);
        fwrite(&epts, sizeof(trash), 1, file);
        fwrite(&epts, sizeof(trash), 1, file);

        void* buffer = malloc(size);
        if (!buffer)
        {
            perror("Memory allocation failure.");
            return false;
        }

        unprocess_pixels(buffer, pixels);
        fwrite(pixels, 1, size, file);
        free(buffer);
        return true;
    }
    return false;
}


void InitialiseHooks();

template<typename T, typename U>
void* DetourFunction(T* From, U* To, int JumpLength);

typedef void (__stdcall *JavaNativeBlit_t)(JNIEnv *env, jobject joSelf, jobject srcData, jobject dstData, jobject clip, jint srcx, jint srcy, jint dstx, jint dsty, jint width, jint height, jint rmask, jint gmask, jint bmask, jboolean needLut);

JavaNativeBlit_t o_JavaNativeBlit;

void __stdcall JavaNativeBlit(JNIEnv *env, jobject joSelf, jobject srcData, jobject dstData, jobject clip, jint srcx, jint srcy, jint dstx, jint dsty, jint width, jint height, jint rmask, jint gmask, jint bmask, jboolean needLut)
{
    //Pre-Render
    o_JavaNativeBlit(env, joSelf, srcData, dstData, clip, srcx, srcy, dstx, dsty, width, height, rmask, gmask, bmask, needLut);

    typedef SurfaceDataOps* (__stdcall *SurfaceData_GetOps)(JNIEnv *env, jobject sData);
    static SurfaceData_GetOps GetOps = nullptr;

    if (!GetOps)
    {
        GetOps = (SurfaceData_GetOps)GetProcAddress(GetModuleHandle("awt.dll"), "_SurfaceData_GetOps@8");
    }

    if (!GetOps)
    {
        return;
    }

    //Hook..
    SurfaceDataOps* srcOps = GetOps(env, srcData);

    SurfaceDataRasInfo srcInfo = {0};
    srcInfo.bounds.x1 = srcx;
    srcInfo.bounds.y1 = srcy;
    srcInfo.bounds.x2 = srcx + width;
    srcInfo.bounds.y2 = srcy + height;

    if (srcOps->Lock(env, srcOps, &srcInfo, SD_LOCK_READ) == SD_SUCCESS)
    {
        srcOps->GetRasInfo(env, srcOps, &srcInfo);
        if (srcInfo.rasBase)
        {
            std::uint8_t* dest = nullptr;
            void *rasBase = reinterpret_cast<std::uint8_t*>(srcInfo.rasBase) + (srcInfo.scanStride * srcy) + (srcInfo.pixelStride * srcx);
            bool isRasterAligned = !(srcInfo.scanStride & 0x03);

            if (isRasterAligned)
            {
                memcpy(dest, rasBase, (srcInfo.scanStride / srcInfo.pixelStride) * height * srcInfo.pixelStride);
            }
            else
            {
                for (int i = 0; i < height; ++i)
                {
                    int offset = (srcInfo.scanStride / srcInfo.pixelStride) * i;
                    memcpy(dest + offset, rasBase, (srcInfo.scanStride / srcInfo.pixelStride));
                    rasBase = static_cast<void*>(reinterpret_cast<std::uint8_t*>(rasBase) + srcInfo.scanStride);
                }
            }

            if (srcOps->Release)
            {
                srcOps->Release(env, srcOps, &srcInfo);
            }
        }

        if (srcOps->Unlock)
        {
            srcOps->Unlock(env, srcOps, &srcInfo);
        }
    }
}

void StartHook()
{
    std::thread([&] {InitialiseHooks();}).detach();
}

DWORD FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, const char* szMask)
{
    auto bCompare = [](const BYTE* pData, const BYTE* bMask, const char* szMask) -> bool
    {
        for(; *szMask; ++szMask, ++pData, ++bMask)
            if(*szMask == 'x' && *pData != *bMask)
                return 0;
        return (*szMask) == 0;
    };

    for(DWORD i = 0; i < dwLen; ++i)
        if (bCompare(reinterpret_cast<std::uint8_t*>(dwAddress + i), bMask, szMask))
            return static_cast<DWORD>(dwAddress + i);
    return 0;
}

template<typename T, typename U>
void* DetourFunction(T* From, U* To, int JumpLength)
{
    std::uint8_t* OrigFunc = reinterpret_cast<std::uint8_t*>(From);
    std::uint8_t* HookFunc = reinterpret_cast<std::uint8_t*>(To);

    DWORD dwProt = 0;
    std::uint8_t* jmp = new std::uint8_t[JumpLength + 5];
    VirtualProtect(OrigFunc, JumpLength, PAGE_READWRITE, &dwProt);
    memcpy(jmp, OrigFunc, JumpLength);

    jmp += JumpLength;
    jmp[0] = 0xE9;
    *reinterpret_cast<DWORD*>(jmp + 1) = static_cast<DWORD>(OrigFunc + JumpLength - jmp) - 5;
    memset(OrigFunc, 0x90, JumpLength);

    OrigFunc[0] = 0xE9;
    *reinterpret_cast<DWORD*>(OrigFunc + 1) = static_cast<DWORD>(HookFunc - OrigFunc) - 5;
    VirtualProtect(OrigFunc, JumpLength, dwProt, &dwProt);
    return (jmp - JumpLength);
}

void InitialiseHooks()
{
    std::thread([]{
        while(!GetModuleHandle("awt.dll"))
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        o_JavaNativeBlit = (JavaNativeBlit_t)GetProcAddress(GetModuleHandle("awt.dll"), "_Java_sun_java2d_windows_GDIBlitLoops_nativeBlit@60");
        DetourFunction(o_JavaNativeBlit, JavaNativeBlit, 5);
    }).detach();
}

#endif // NATIVEHOOKS_HXX_INCLUDED
